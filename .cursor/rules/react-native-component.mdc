---
alwaysApply: true
---

# Component Function Style

## Use Function Expressions Instead of Function Declarations

All components must be defined using function expressions (arrow functions) instead of function declarations.

**Don't do this:**

```tsx
function Component() {
  return <View />;
}
```

**Instead, do this:**

```tsx
const Component = () => {
  return <View />;
};
```

This applies to all component definitions, including exported components:

**Don't do this:**

```tsx
export function Component() {
  return <View />;
}
```

**Instead, do this:**

```tsx
export const Component = () => {
  return <View />;
};
```

# Component Structure

All components must follow a consistent structure from top to bottom. This ensures readability, maintainability, and makes it easier to locate specific code sections.

## Module-Level Structure (Outside Component)

The following sections must appear in this exact order at the module level (outside the component function):

### 1. Imports

Group imports in this order:

1. React and React Native core imports
2. Third-party library imports
3. Local component imports
4. Local utility/type imports
5. Type-only imports (using `import type`)

**Example:**

```tsx
import { useCallback, useEffect, useRef, useState } from "react";
import { View, Text, Pressable } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { useSharedValue, useAnimatedStyle, withSpring } from "react-native-reanimated";
import { ArrowLeft } from "lucide-react-native";
import Pagination from "../components/product/pagination";
import { INITIAL_DATA } from "../lib/data/data";
import type { ProductItem } from "../lib/data/data";
```

### 2. Constants

All module-level constants must be named in UPPERCASE (using SCREAMING_SNAKE_CASE). Constants that don't depend on props or state should be defined at the module level.

**Don't do this:**

```tsx
import { View } from "react-native";
import { FadeIn } from "react-native-reanimated";

const Component = () => {
  const FADE_IN = FadeIn.duration(300);
  // ... rest of component
};
```

**Instead, do this:**

```tsx
import { View } from "react-native";
import { FadeIn } from "react-native-reanimated";

const FADE_IN = FadeIn.duration(300);
const MAX_ITEMS = 10;
const ANIMATION_DURATION = 300;

const Component = () => {
  // ... rest of component
};
```

### 3. Types

Define all TypeScript types, interfaces, and prop types at the module level, before the component definition.

**Example:**

```tsx
type ComponentProps = {
  initialData: ProductItem[];
  onPress?: () => void;
};

type InternalState = {
  isActive: boolean;
  count: number;
};
```

### 4. Component Definition

The component function itself comes after all module-level code.

## Component-Level Structure (Inside Component)

Inside the component function, follow this exact order:

### 1. State

Define all React state (`useState`) and shared values (`useSharedValue`) first.

**Example:**

```tsx
const Component = ({ initialData, onPress }: ComponentProps) => {
  const [data, setData] = useState([...initialData]);
  const [isActive, setIsActive] = useState(false);
  const scale = useSharedValue(1);
  const opacity = useSharedValue(1);
```

### 2. Data-Related Variables

Define computed values, derived data, and configuration objects that depend on state or props.

**Example:**

```tsx
const listHeight = screenWidth * 0.6;
const viewabilityConfig = useRef({
  itemVisiblePercentThreshold: 50,
  minimumViewTime: 0,
}).current;
```

### 3. Hooks

Group hooks in this order:

1. Refs (`useRef`)
2. Layout/Dimension hooks (`useWindowDimensions`, `useSafeAreaInsets`)
3. Effect hooks (`useEffect`)
4. Callback hooks (`useCallback`, `useMemo`)
5. Reanimated hooks (`useAnimatedStyle`, `useAnimatedReaction`, `useDerivedValue`)

**Example:**

```tsx
const listRef = useRef<LegendListRef>(null);
const insets = useSafeAreaInsets();
const { width: screenWidth } = useWindowDimensions();

useEffect(() => {
  // effect logic
}, []);

const handlePress = useCallback(() => {
  // callback logic
}, []);

const animatedStyle = useAnimatedStyle(() => {
  return { transform: [{ scale: scale.get() }] };
});
```

### 4. Callbacks

Define all event handlers and callback functions. Use `useCallback` for callbacks passed to child components or used in dependencies.

**Example:**

```tsx
const handleItemPress = useCallback((item: ProductItem) => {
  // handler logic
}, []);

const onViewableItemsChanged = useRef(({ viewableItems }: { viewableItems: ViewToken[] }) => {
  // handler logic
}).current;
```

### 5. Animation-Related Logic and Styles

Group all animation-related code together:

- Animation style hooks (`useAnimatedStyle`, `useDerivedValue`)
- Animation configuration
- Gesture handlers (if using React Native Gesture Handler)

**Example:**

```tsx
const animatedStyle = useAnimatedStyle(() => {
  return {
    transform: [{ scale: scale.get() }],
    opacity: opacity.get(),
  };
});

const derivedValue = useDerivedValue(() => {
  return scale.get() * 2;
});
```

### 6. Render

The return statement and JSX come last.

**Example:**

```tsx
  return (
    <View className="flex-1">
      {/* JSX content */}
    </View>
  );
};
```

### 7. Stylesheet (If Needed)

If using `StyleSheet.create`, define it after the component but before exports. Prefer Tailwind/NativeWind classes over StyleSheet when possible.

**Example:**

```tsx
const Component = () => {
  // ... component code
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});

export default Component;
```

## Complete Example

```tsx
import { useCallback, useEffect, useRef, useState } from "react";
import { View, Text, Pressable } from "react-native";
import { useSharedValue, useAnimatedStyle, withSpring } from "react-native-reanimated";
import type { ProductItem } from "../lib/data/data";

const FADE_DURATION = 300;
const MAX_ITEMS = 10;

type ComponentProps = {
  initialData: ProductItem[];
  onPress?: () => void;
};

const Component = ({ initialData, onPress }: ComponentProps) => {
  // State
  const [data, setData] = useState([...initialData]);
  const scale = useSharedValue(1);

  // Data-related variables
  const itemCount = data.length;

  // Hooks
  const listRef = useRef(null);

  useEffect(() => {
    // effect logic
  }, []);

  // Callbacks
  const handlePress = useCallback(() => {
    onPress?.();
  }, [onPress]);

  // Animation-related logic and styles
  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ scale: scale.get() }],
    };
  });

  // Render
  return (
    <View className="flex-1">
      <Text>{itemCount}</Text>
    </View>
  );
};

export default Component;
```

## Additional Guidelines

- **Memoization**: Memoize expensive computations, callbacks passed to children, and animation objects to prevent unnecessary re-renders.
- **Hook Ordering**: Always maintain consistent hook ordering. Don't conditionally call hooks.
- **Separation of Concerns**: Keep animation logic separate from business logic. Group related functionality together.
- **Constants Inside Component**: If a constant depends on props or state, place it in the "Data-related variables" section after state.

# Variable Naming

## Declarative and Clear Variable Names

All variable names must be declarative and clearly state their purpose. This applies to constants, state variables, computed values, refs, callbacks, and all other variables.

**Don't do this** – ambiguous or unclear names:

```tsx
const data = useState([]);
const rStyle = useAnimatedStyle(() => {});
const item = viewableItems[0];
const idx = data.findIndex(...);
const insets = useSafeAreaInsets();
```

**Instead, do this** – declarative names that clearly state purpose:

```tsx
const productItems = useState([]);
const animatedIndicatorStyle = useAnimatedStyle(() => {});
const firstViewableItem = viewableItems[0];
const targetProductIndex = data.findIndex(...);
const safeAreaInsets = useSafeAreaInsets();
```

### Naming Conventions

- **State variables**: Use descriptive nouns that indicate what the state represents (e.g., `productItems`, `currentProductItem`, `isLoading`)
- **Refs**: Include "Ref" suffix (e.g., `productListRef`, `scrollViewRef`)
- **Animated styles**: Include "Animated" or "Style" suffix (e.g., `animatedIndicatorStyle`, `containerAnimatedStyle`)
- **Callbacks**: Use verb phrases that describe the action (e.g., `handleItemPress`, `onViewableItemsChanged`)
- **Computed values**: Use descriptive names that explain what is computed (e.g., `productListHeight`, `totalPrice`)
- **Constants**: Use UPPERCASE_SCREAMING_SNAKE_CASE with descriptive names (e.g., `DASH_HEIGHT`, `ANIMATION_DURATION`)

**Examples:**

```tsx
// State
const [productItems, setProductItems] = useState([]);
const [currentProductItem, setCurrentProductItem] = useState(null);
const currentSlideIndex = useSharedValue(0);

// Refs
const productListRef = useRef(null);
const scrollViewRef = useRef(null);

// Animated styles
const animatedIndicatorStyle = useAnimatedStyle(() => {});
const containerAnimatedStyle = useAnimatedStyle(() => {});

// Callbacks
const handleProductItemPress = useCallback(() => {});
const onViewableItemsChanged = useRef(() => {}).current;

// Computed values
const productListHeight = screenHeight * 0.6;
const totalProductCount = productItems.length;

// Constants
const DASH_HEIGHT = 1;
const ANIMATION_DURATION = 300;
```

# Component Organization

## One File, One Component Pattern

All components must be lightweight and follow the **one file, one component** pattern. Each component file should contain only a single component definition.

**Don't do this** – multiple components in one file:

```tsx
// components/product.tsx
const ProductCard = () => {
  return <View>...</View>;
};

const ProductList = () => {
  return <View>...</View>;
};

const ProductHeader = () => {
  return <View>...</View>;
};
```

**Instead, do this** – one component per file:

```tsx
// components/product/product-card.tsx
const ProductCard = () => {
  return <View>...</View>;
};

export default ProductCard;
```

```tsx
// components/product/product-list.tsx
const ProductList = () => {
  return <View>...</View>;
};

export default ProductList;
```

## Feature Slice Pattern and App Animation Structure

When a component needs to be split into smaller pieces, follow the **feature slice pattern** and the **App Animation Structure** as defined in `README.md`. All files must be organized within the corresponding `components` and `lib` folders inside `src/apps/[some-app]/`.

### Directory Structure

Each app follows this structure:

```
src/apps/[some-app]/
├── components/           # Components specific to this app
│   └── [feature]/        # Feature-specific components (optional grouping)
│       └── [component].tsx
├── lib/                  # Hooks, utils, providers, constants for this app
│   └── [feature]/        # Feature-specific utilities (optional grouping)
│       └── [utility].ts
└── routes/               # Route files for the app
    └── [route].tsx
```

### Component Splitting Guidelines

**When to split a component:**

1. **Complexity**: Component exceeds ~200-300 lines
2. **Reusability**: Component or its parts are used in multiple places
3. **Feature Separation**: Component handles multiple distinct features
4. **Testing**: Component logic needs isolated testing

**How to split:**

1. **Extract reusable UI components** → `components/[feature]/[component-name].tsx`
2. **Extract business logic/hooks** → `lib/[feature]/[hook-name].ts` or `lib/[feature]/[util-name].ts`
3. **Extract constants/types** → `lib/[feature]/[constants].ts` or `lib/[feature]/[types].ts`
4. **Keep route components** → `routes/[route-name].tsx`

**Example:**

**Before** – single large component:

```tsx
// routes/product.tsx (300+ lines)
const Product = () => {
  // State, hooks, callbacks, animations, render all in one file
  return <View>...</View>;
};
```

**After** – split following feature slice pattern:

```tsx
// routes/product.tsx (main route component)
import ProductList from "../components/product/product-list";
import ProductHeader from "../components/product/product-header";
import { useProductData } from "../lib/product/use-product-data";
import { useProductAnimations } from "../lib/product/use-product-animations";

const Product = () => {
  const { data, handlers } = useProductData();
  const { animatedStyles } = useProductAnimations();

  return (
    <View>
      <ProductHeader />
      <ProductList data={data} animatedStyles={animatedStyles} />
    </View>
  );
};
```

```tsx
// components/product/product-list.tsx
const ProductList = ({ data, animatedStyles }) => {
  return <View>...</View>;
};
```

```tsx
// components/product/product-header.tsx
const ProductHeader = () => {
  return <View>...</View>;
};
```

```tsx
// lib/product/use-product-data.ts
export const useProductData = () => {
  // Data fetching, state management logic
  return { data, handlers };
};
```

```tsx
// lib/product/use-product-animations.ts
export const useProductAnimations = () => {
  // Animation logic
  return { animatedStyles };
};
```

### Import Paths

When importing from within the same app, use relative paths:

```tsx
// routes/product.tsx
import ProductList from "../components/product/product-list";
import { useProductData } from "../lib/product/use-product-data";
```

When importing shared utilities, use the `@/src/shared` alias:

```tsx
import { simulatePress } from "@/src/shared/lib/utils/simulate-press";
```
