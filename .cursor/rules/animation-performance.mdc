---
alwaysApply: true
---

# Animation Performance Tips

## Avoid Reading Shared Values on the JS Thread

Reading shared values is allowed only from worklets running on the UI thread. You should avoid reading shared values in the React Native runtime on the JavaScript thread.

```tsx
const sv = useSharedValue(0);

useEffect(() => {
  console.log(sv.get()); // ❌ reading shared value in the RN runtime (not recommended)
}, []);

const animatedStyle = useAnimatedStyle(() => {
  return { opacity: sv.get() }; // ✅ this is okay
});
```

When you read the `sv.get()` in the React Native runtime, the JS thread will get blocked until the value is fetched from the UI thread. In most cases it will be negligible, but if the UI thread is busy or you are reading a value multiple times, the wait time needed to synchronize both threads may significantly increase.

## Don't Read or Modify Shared Values During Render

Don't read or modify the value of a shared value during a component's render. Access to `value` property or calling `get()`/`set()` methods is a side-effect. Triggering side-effects during render violates the Rules of React. All reads from and writes to a shared value should happen in relevant callbacks which aren't executed during render, i.e. in `useAnimatedStyle` or `useEffect` hooks.

**Don't do this** – accessing shared values during render:

```tsx
function Component() {
  const sv = useSharedValue(0);

  // ❌ Reading during render violates Rules of React
  const currentValue = sv.value;

  return <View />;
}
```

**Instead**, access shared values in appropriate hooks:

```tsx
function Component() {
  const sv = useSharedValue(0);

  // ✅ Reading in useAnimatedStyle is okay
  const animatedStyle = useAnimatedStyle(() => {
    return { opacity: sv.value };
  });

  // ✅ Reading in useEffect is okay
  useEffect(() => {
    console.log(sv.value);
  }, []);

  return <Animated.View style={animatedStyle} />;
}
```

## Avoid Unnecessary Re-renders

Use shared values instead of component state for animation-related values. Shared values update on the UI thread without triggering React re-renders, which improves performance.

**Don't do this** – using component state for animation values:

```tsx
const [scale, setScale] = useState(1);

// This triggers re-renders on every update
setScale(1.2);
```

**Instead**, use shared values:

```tsx
const scale = useSharedValue(1);

// This updates on the UI thread without re-renders
scale.set(withSpring(1.2));
```

It's okay to create animated contexts for components as long as they don't contain any state which can cause re-renders. Animated contexts that only provide shared values or animation configurations won't trigger unnecessary re-renders.

## Avoid Animating Too Many Components at Once

Reanimated is perfectly capable of animating several dozens of components at once. However, if there's too many components to be animated simultaneously, performance can be affected. As a rule of thumb, you should animate no more than 100 components for low-end Android devices and no more than 500 components for iOS. For more complex animations, consider using Reanimated with react-native-skia instead of rendering individual React components.

These optimizations will keep your animations buttery smooth. Now let's look at how to debug issues when they arise.

## Memoize Animations

Every time your component re-renders, any animations you create inside the render function are recreated. This wastes memory and processing time.

**Don't do this** – creating a new animation object on every render:

```tsx
{
  items.map((item) => <Animated.View entering={FadeIn.duration(300)} key={item.id} />);
}
```

**Instead**, create the animation once outside the component or memoize it:

```tsx
const fadeIn = FadeIn.duration(300);
{
  items.map((item) => <Animated.View entering={fadeIn} key={item.id} />);
}
```

By storing the animation in a constant, you create it once and reuse the same object for all items. This reduces memory allocation and garbage collection, keeping your animations smooth even with long lists.

## Memoize Frame Callbacks

If you are using `useFrameCallback`, you should wrap the frame callback worklet inside `useCallback` in order to memoize it. This way, the frame callback won't need to be recreated and thus registered on every render. If you are using React Compiler, the frame callback should be memoized automatically.

```tsx
useFrameCallback(
  useCallback(() => {
    "worklet";
    // your frame callback logic here
  }, [...deps])
);
```

## Memoize Gesture Objects

If you are using React Native Gesture Handler, you should wrap gesture objects like `Gesture.Tap()` or similar inside `useMemo` in order to memoize them. This way, the gestures won't need to be reattached on every render. This is particularly important for FlatList items where performance is key. If you are using React Compiler, the gesture objects should be memoized automatically.

```tsx
const pan = useMemo(
  () =>
    Gesture.Pan()
      .onStart(() => {})
      .onEnd(() => {}),
  [...deps]
);
```

## Optimize useAnimatedStyle Calculations

If you're doing expensive calculations inside `useAnimatedStyle`, those calculations run every frame, even if the dependencies haven't changed.

**Don't do this** – recalculating every frame:

```tsx
const animatedStyle = useAnimatedStyle(() => ({
  width: Math.min(Math.max(offset.get() * 2, 100), 500),
}));
```

**Instead**, use `useDerivedValue` to compute the value only when dependencies change:

```tsx
const width = useDerivedValue(() => Math.min(Math.max(offset.get() * 2, 100), 500));

const animatedStyle = useAnimatedStyle(() => ({
  width: width.get(),
}));
```

Now the complex calculation only runs when `offset.value` changes, not on every frame. The `useAnimatedStyle` just reads the pre-computed width, which is much faster.

## Batch Updates

When you update multiple shared values, each update can trigger a separate re-render. This creates unnecessary work for the UI thread.

**Don't do this** – triggering multiple re-renders:

```tsx
scale.set(withSpring(1.2));
opacity.set(withSpring(0.8));
```

**Instead**, batch the updates using `scheduleOnUI` (react-native-worklets). Define the function outside using `useCallback` and pass the function reference:

```tsx
const batchUpdates = useCallback(() => {
  scale.set(withSpring(1.2));
  opacity.set(withSpring(0.8));
}, []);

scheduleOnUI(batchUpdates);
```

The `scheduleOnUI` function ensures both updates happen in the same frame, so the UI only re-renders once. This is especially important when updating many values at once, like in complex gestures or choreographed animations.

## Prefer Transform Over Layout

Animating non-layout properties (like `transform`, `opacity`, or `backgroundColor`) is generally more performant than animating styles that affect layout (like `top`/`left`, `width`/`height`, `margin`, or `padding`). That's because the latter group requires an additional step of layout recalculation on each animation frame.

Animating layout properties like `width`, `height`, `margin`, or `padding` forces React Native to recalculate the position of every element that depends on the changing element. This is expensive.

**Don't do this** – expensive layout recalculation:

```tsx
width: withSpring(newWidth);
top: withSpring(newTop);
```

**Instead**, use transform properties and other non-layout styles, which only affect the visual appearance without triggering layout:

```tsx
transform: [{ translateX: withSpring(offsetX), translateY: withSpring(offsetY) }];
opacity: withSpring(0.5);
backgroundColor: withSpring("rgba(255, 0, 0, 0.5)");
```

Transform operations are hardware-accelerated and don't affect layout, making them dramatically faster. Whenever possible, use `translateX/Y` instead of changing `top`/`left`, `scale` instead of changing `width`/`height`, and `rotate` instead of changing orientation.

## Optimize Scroll Handlers for Animated Lists

If you use animated lists with Reanimated `scrollHandler`, use `scrollEventThrottle={16}` to limit how often scroll events will be fired while scrolling. The value `16` corresponds to 60fps (16ms per frame). This may be useful when expensive work is performed in response to scrolling. Values <= 16 will disable throttling, regardless of the refresh rate of the device.

```tsx
<Animated.FlatList
  onScroll={scrollHandler}
  scrollEventThrottle={16}
  // ... other props
/>
```

This ensures scroll events are fired at a consistent rate, preventing performance issues when handling scroll events with Reanimated worklets.
